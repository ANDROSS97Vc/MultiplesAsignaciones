# -*- coding: utf-8 -*-
"""EVALUACION_ASIGNACIONES.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11ZQ6CHZ6K1DAbellP_ChnQLbbElAXldX

# **EVALUACION CON MULTIPLES ASIGNACIONES**
"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import f1_score, roc_auc_score
from google.colab import drive
import time


drive.mount('/content/drive', force_remount=True)
ruta_carga = '/content/drive/MyDrive/dataset/datasetFINALFINAL1.csv'

df = pd.read_csv(ruta_carga, sep=';', decimal=',')
df.columns = df.columns.str.strip()

print(f"‚úÖ Dataset cargado. Dimensiones: {df.shape}")

X = df.drop('cardio', axis=1)
y = df['cardio']

modelo_pipeline = Pipeline(steps=[
    ('classifier', LogisticRegression(
        solver='liblinear',
        class_weight='balanced',
        random_state=42
    ))
])

# Configuracion de las 100 Iteraciones
N_ITERACIONES = 100
f1_scores = []
auc_scores = []
recall_scores = []
start_time = time.time()

print(f"\nüîÑ Iniciando {N_ITERACIONES} asignaciones aleatorias (Validacion Monte Carlo)...")

for i in range(N_ITERACIONES):
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.20, random_state=i, stratify=y
    )

    # Entrenar el modelo
    modelo_pipeline.fit(X_train, y_train)

    # Predecir probabilidades
    y_prob = modelo_pipeline.predict_proba(X_test)[:, 1]

    # Aplicar el Threshold optimizado
    threshold = 0.4
    y_pred_adj = (y_prob >= threshold).astype(int)

    # Guardar metricas de esta vuelta
    f1_scores.append(f1_score(y_test, y_pred_adj))
    auc_scores.append(roc_auc_score(y_test, y_prob))

end_time = time.time()
tiempo_total = end_time - start_time
print("‚úÖ Proceso de iteraciones completado.")

# Calculo de Estadisticas (Mediana y Rangos)
mediana_f1 = np.median(f1_scores)
mediana_auc = np.median(auc_scores)
std_f1 = np.std(f1_scores)

print("\n--- üìù Resultados de Estabilidad (100 Iteraciones) ---")
print(f"Mediana del F1-Score: {mediana_f1:.4f}")
print(f"Mediana del ROC AUC:  {mediana_auc:.4f}")
print(f"Desviaci√≥n Est√°ndar F1: {std_f1:.4f} (Bajo es mejor, indica estabilidad)")
print(f"\nRango de F1-Scores: [{np.min(f1_scores):.4f} - {np.max(f1_scores):.4f}]")
print(f"Tiempo total de ejecuci√≥n: {tiempo_total:.2f} segundos")